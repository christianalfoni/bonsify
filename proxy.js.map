{"version":3,"file":"proxy.js","sourceRoot":"","sources":["proxy.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Cache for storing proxies to avoid recreating them for the same target\n * We use separate caches for mutable and readonly proxies\n */\nconst proxyCache = new WeakMap<any, any>();\nconst readonlyProxyCache = new WeakMap<any, any>();\n\nlet globalSnapshot = 0;\nlet notify = () => {};\n\nexport function getGlobalSnapshot() {\n  return globalSnapshot;\n}\n\nexport function subscribe(notifier: () => void) {\n  notify = notifier;\n\n  return () => {\n    notify = () => {};\n  };\n}\n\n/**\n * Symbol used to access the proxy target and readonly state\n */\nexport const PROXY_TARGET = Symbol(\"PROXY_TARGET\");\n\n/**\n * Clears readonly proxy cache for targets affected by mutations\n * This ensures value comparison works correctly in React\n */\nfunction clearReadonlyProxyCache(targets: any[]) {\n  for (const target of targets) {\n    readonlyProxyCache.delete(target);\n  }\n}\n\n/**\n * List of array methods that mutate the array\n */\nconst mutatingArrayMethods = [\n  \"push\",\n  \"pop\",\n  \"shift\",\n  \"unshift\",\n  \"splice\",\n  \"sort\",\n  \"reverse\",\n];\n\n/**\n * Map of array methods that iterate over array elements\n * Each handler wraps the callback to ensure reactive behavior\n */\ntype IteratingMethodHandler = (args: any[]) => void;\n\nconst iteratingArrayMethods: Record<string, IteratingMethodHandler> = {\n  // Methods that take a callback as first argument\n  map: (args) => {\n    args[0] = createProxy(args[0]);\n  },\n  filter: (args) => {\n    args[0] = createProxy(args[0]);\n  },\n  find: (args) => {\n    args[0] = createProxy(args[0]);\n  },\n  findIndex: (args) => {\n    args[0] = createProxy(args[0]);\n  },\n  forEach: (args) => {\n    args[0] = createProxy(args[0]);\n  },\n  some: (args) => {\n    args[0] = createProxy(args[0]);\n  },\n  every: (args) => {\n    args[0] = createProxy(args[0]);\n  },\n\n  // Methods that take initial value as second argument\n  reduce: (args) => {\n    args[1] = createProxy(args[1]);\n  },\n  reduceRight: (args) => {\n    args[1] = createProxy(args[1]);\n  },\n};\n\n/**\n * Base proxy handler with common trap implementations for both objects and arrays\n */\nfunction createBaseProxyHandler(updateReference: () => void) {\n  return {\n    // Support checking if an object is a proxy\n    has(target: any, key: string | symbol) {\n      if (key === PROXY_TARGET) {\n        return true;\n      }\n      return Reflect.has(target, key);\n    },\n\n    // Handle property setting with reactivity\n    set(target: any, key: string | symbol, value: any) {\n      const wasSet = Reflect.set(target, key, value);\n\n      // Don't trigger notifications for symbol properties\n      if (typeof key === \"symbol\" || !wasSet) {\n        return wasSet;\n      }\n\n      updateReference();\n      globalSnapshot++;\n      notify?.();\n      return wasSet;\n    },\n\n    // Handle property deletion with reactivity\n    deleteProperty(target: any, key: string | symbol) {\n      const wasDeleted = Reflect.deleteProperty(target, key);\n\n      // Don't trigger notifications for symbol properties\n      if (typeof key === \"symbol\" || !wasDeleted) {\n        return wasDeleted;\n      }\n\n      updateReference();\n      globalSnapshot++;\n      notify?.();\n      return wasDeleted;\n    },\n  };\n}\n\n/**\n * Creates a proxy for an array with reactive behavior\n */\nfunction createArrayProxy(target: any[], updateReference: () => void) {\n  const baseHandler = createBaseProxyHandler(updateReference);\n\n  return new Proxy(target, {\n    ...baseHandler,\n\n    // Enhanced get trap for arrays to handle special array methods\n    get(target: any[], key: string | symbol) {\n      const result = Reflect.get(target, key);\n\n      // Handle proxy target access\n      if (key === PROXY_TARGET) {\n        return { target };\n      }\n\n      // Handle iterator access\n      if (key === Symbol.iterator) {\n        return result;\n      }\n\n      // Return symbols directly\n      if (typeof key === \"symbol\") {\n        return result;\n      }\n\n      // Handle mutating array methods\n      if (mutatingArrayMethods.includes(key as string)) {\n        const originalMethod = target[key as any];\n\n        return (...args: any[]) => {\n          const result = originalMethod.apply(target, args);\n\n          // Clear readonly cache to ensure value comparison works correctly\n          updateReference();\n          globalSnapshot++;\n          notify?.();\n\n          return result;\n        };\n      }\n\n      // Handle iterating array methods\n      if (key in iteratingArrayMethods) {\n        const originalMethod = target[key as any];\n        const handler = iteratingArrayMethods[key as string];\n\n        return (...args: any[]) => {\n          const result = originalMethod.apply(\n            target,\n            [\n              (...methodArgs: any[]) => {\n                handler(methodArgs);\n                return args[0](...methodArgs);\n              },\n            ].concat(args.slice(1))\n          );\n\n          return createProxy(result);\n        };\n      }\n\n      // Recursively create proxies for nested objects\n      return createProxy(result);\n    },\n  });\n}\n\n/**\n * Creates a proxy for an object with reactive behavior\n */\nfunction createObjectProxy(target: object, updateReference: () => void) {\n  const baseHandler = createBaseProxyHandler(updateReference);\n\n  return new Proxy(target, {\n    ...baseHandler,\n\n    // Enhanced get trap for objects\n    get(target: any, key: string | symbol) {\n      const result = Reflect.get(target, key);\n\n      // Handle proxy target access\n      if (key === PROXY_TARGET) {\n        return target;\n      }\n\n      // Handle iterator access\n      if (key === Symbol.iterator) {\n        return result;\n      }\n\n      // Return symbols, functions, and promises directly\n      if (\n        typeof key === \"symbol\" ||\n        typeof result === \"function\" ||\n        (result && result instanceof Promise)\n      ) {\n        return result;\n      }\n\n      // Handle non-configurable properties\n      const descriptor = Object.getOwnPropertyDescriptor(target, key);\n      if (descriptor && !descriptor.configurable) {\n        return result;\n      }\n\n      // Recursively create proxies for nested objects\n      return createProxy(result, () => {});\n    },\n  });\n}\n\n/**\n * Creates a reactive proxy for an object or array\n * @param target The object to make reactive\n * @param readonly Whether the proxy should be readonly\n * @param targets Chain of parent targets for cache invalidation\n * @returns A reactive proxy of the target\n */\nexport function createProxy<T>(target: T, updateReference: () => void): T {\n  // Type guard for non-objects\n  if (target === null || typeof target !== \"object\") {\n    return target;\n  }\n\n  return createProxyInternal(target as object, updateReference) as T;\n}\n\n/**\n * Internal implementation of createProxy that works with objects\n * This separation allows us to maintain type safety while handling the proxy creation\n */\nfunction createProxyInternal(\n  target: object,\n  updateReference: () => void\n): object {\n  // We've already checked for primitives in the public function\n\n  // Handle already proxied objects\n  if (PROXY_TARGET in target) {\n    const cachedProxy = proxyCache.get(target[PROXY_TARGET]);\n\n    if (cachedProxy) {\n      return cachedProxy;\n    }\n  }\n\n  // Create appropriate proxy based on target type\n  const proxy = Array.isArray(target)\n    ? createArrayProxy(target, updateReference)\n    : createObjectProxy(target, updateReference);\n\n  // Cache the proxy for future reuse\n  proxyCache.set(target, proxy);\n\n  return proxy;\n}\n"]}